# 排序算法

实现各种常用排序算法


## 设计思想

1. `generator` 

shell脚本用于生成随机数。

- 接受一个参数用于指定生成随机数个数
- 将生成结果输出至标准输出，第一行为整数个数，第二行为整数数组，以‘ ’分割


2. `sort`

支持各种常用排序算法

- q: 快速排序
- i: 插入排序
- h: 堆排序
- m: 归并排序
- b: 冒泡排序
- s: 选择排序

输入：读取标准输入，以' '或'\n'为分割符，先读取一个整数表示数组长度，并分配内存，再读取数组内容
输出：标准输出打印最多最后3行排好序的数组内容，一个空行后打印整数个数+排序耗时（单位毫秒）


## 用法示例

`./generator 10000 | ./sort q`

生成**10000**个随机数，通过快速排序算法进行排序并统计耗时。




## 算法对比

### 比较类排序

|   算法   |                                    核心思想                                    |  平均时间复杂度  | 空间复杂度 |  是否稳定   |
|:--------:|:-------------------------------------------------------------------------------|:----------------:|:----------:|:-----------:|
| 冒泡排序 | 从头至尾对比相邻元素，较大值向后浮动，直至完成                                 |     O(N ^ 2)     |   O(1)     |      是     |
| 选择排序 | 每次遍历寻找最大(小)值放置首/尾，直至完成                                      |     O(N ^ 2)     |   O(1)     |      否     |
| 插入排序 | 划分为有序和无序2部分，每次从无序中选择一个插入至有序的正确位置，直至完成      |     O(N ^ 2)     |   O(1)     |      是     |
| 希尔排序 | 插入排序优化的一种，分步长排序，不断缩减步长至1 ，即可完成排序                 |    O(N ^ 1.3)    |   O(1)     |      是     |
| 归并排序 | 分治思想典范，将2个有序子集合并为一个有序集合                                  |     O(NlogN)     |   O(N)     |      是     |
| 快速排序 | 通过一趟遍历将数组进行划分，左边小于某个值，右边大于某个值，然后递归左右子集   |     O(NlogN)     |  O(NlogN)  |      否     |
| 堆排序   | 通过堆的树状结构，保证节点的相对有序，每次节点变动调整仅需树的深度logN         |     O(NlogN)     |  O(NlogN)  |      否     |


冒泡排序、选择排序、插入排序、希尔排序在数据规模小的时候表现不错。

堆排序、插入排序在数据规模大的时候表现优越，对于快速排序要优化避免最坏情况的影响。

归并排序性能良好，主要考虑空间消耗问题。


### 非比较类排序


**待补充**

- 基数排序
- 计数排序
- 桶排序
